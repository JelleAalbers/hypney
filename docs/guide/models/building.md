Building models from other models
=================================


Fixing parameters
-----------------
The `Model.fix` method returns a model with fewer parameters than the original. You supply which parameters to fix to which values.

The `Model.fix_except` method returns a model with all parameters but the ones you specify fixed to their defaults.


Reparametrize
--------------

The `Model.reparametrize` method returns a model with new parameters related to the old parameters. You supply a function giving a dictionary of old parameters from a dictionary of new parameters.



Cut
---
The `Model.cut` method returns a new model for data thas has been restricted to an interval / rectangular region, after it was generated by the first model.

The new model takes the same parameters, which are simply passed on to the underlying model. For example, `loc` shifts the uncut model, while keeping the cut in place:

```python
m = hp.norm()
m_cut = m.cut(-2, 2)

m.plot_pdf()
m_cut.plot_pdf()
m_cut(loc=1).plot_pdf()
```

The figure above shows the PDFs of:
  * Blue: a standard normal
  * Orange: this model cut to (-2, 2)
  * Green: as orange, but with a different `loc` parameter. Notice the cut has not changed, but the mode has shifted to 1.

The total rate of a cut model is reduced by the cut's efficiency. The differential rate is zero outside the cut, and unaffected inside the cut.

```python
m = hp.norm(rate=10)
m_cut = m.cut(0, None)
assert m_cut.rate() == 5

m.plot_diff_rate()
m_cut.plot_diff_rate()
```

Shift and scale
---------------
The `Model.shift` and `Model.scale` method return models for data that has been shifted (added to a constant) or scaled (multiplied by a constant) after being generated from the original model.

```python
m_orig = hp.norm()
m_orig.plot_pdf()

m_scaled = m_orig.scale(2)
m_scaled.plot_pdf()
```

As with a cut model, the new model takes the same parameters, which are simply passed on to the underlying model. For example:

```python
m_orig(loc=2).plot_pdf()
m_scaled(loc=2).plot_pdf()
```
Setting `m_scaled`'s loc to 2 caused the model's mean to shift to 4, not 2. Remember `m_scaled` models that that is generated from a normal, then multiplied by 2. Thus, moving the mean of the normal to 2 indeed moves the mean of the resulting data to 4.

(You can use `Model.shift_and_scale` for data that was first shifted, then scaled. This is very slightly more efficient than calling `Model.shift(...).scale(...)`.)



Sum / mixture
--------------
You can create mixture models with the `+` operator. This produces a model for data created from multiple models joined/concatenated together. The rate of the summed model is the sum of the original models' rates.

```python
m0 = hp.norm()
m1 = hp.norm(loc=4, rate=2)
m_sum = m0 + m1
m_sum.plot_pdf()
m_sum.rate() == 3
```

You can also use `Model.mix_with(*other_models)` and `hypney.models.mixture(*models)` instead of the power operator. This gives additional options, such as the ability to share parameters with the same name:

```python
m_shared = hp.mixture(m0, m1, share='scale')
m_shared.plot_pdf()
m_shared(scale=0.7).plot_pdf()
```

By default, each model's parameter is given a new unique name. In case of name clashes, as in the example above, parameters are renamed `{model_name}_{param_name}`; if the models are not named, "m{I}" is used, where {I} is the index of the model in the mixture.

```python
m_sum.param_names == ('m0_rate', 'm0_loc', 'm0_scale', 'm1_rate', 'm1_loc', 'm1_scale')
m_shared.param_names == ('m0_rate', 'm0_loc', 'scale', 'm1_rate', 'm1_loc')
```


Tensor Product
---------------
The power operator `**` creates a model for multiple observables from the same events, generated by different independent models. This is known as a 'tensor product' between distributions.

For example, this generates a two-dimensional model for data normally distributed along the first, and uniformly along the second axis.

```python
m_2d = hp.norm() ** hp.uniform()

data = m_2d.rvs(1_000)
plt.scatter(data[:,0], data[:,1], c=m_2d.pdf(data), vmin=0)
plt.colorbar(label='PDF')
```

You can also use `Model.tensor_with(*other_models)` and `hypney.models.tensor_product(*models)` instead of the power operator.